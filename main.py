import folium
import streamlit as st
from streamlit_folium import st_folium
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.figure_factory as ff
import hydralit_components as hc
from folium.plugins import MarkerCluster
from streamlit_folium import folium_static
import ipywidgets as widgets
from ipywidgets import interactive
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import statsmodels.api as sm
import geopandas as gpd
import pydeck as pdk
from joblib import dump
from joblib import load

geo_df = gpd.read_file('C:/Users/r.irani/Desktop/streamlit/geoBoundaries-UKR-ADM1_simplified.geojson')
ukraine_data = pd.read_csv('C:/Users/r.irani/Desktop/streamlit/ukraine_data.csv')

st.set_page_config(layout="wide",page_title=None)

# Navigation Bar Design
menu_data = [
    {'label': "Home"},
    {'label': "EDA"},
    {'label': 'Vulnerability Scores'},
    {'label': 'Vulnerability Map'},
    {'label': 'Score Calculation'},
    {'label': 'Vulnerability Level'},
]

# Set the Navigation Bar with active/inactive text style modification
menu_id = hc.nav_bar(menu_definition=menu_data,
                     sticky_mode='sticky',
                     sticky_nav=True,
                     hide_streamlit_markers=True,
                     override_theme={'txc_inactive': '#000000',  # Normal black text color for inactive items
                                     'menu_background': 'rgba(0,0,0,0)',  # Transparent background
                                     'txc_active': '#0864C5',  # Blue text color for active item
                                     })

#---------------------------------------------------------------------

# Home Page

if menu_id == "Home":
    # Splitting the layout into two columns of identical width
    col1, col2 = st.columns(2)

    with col1:
        st.write(" ")
        st.write(" ")
        st.write(" ")
        st.write(" ")
        st.write(" ")
        st.write(" ")
        st.write(" ")
        st.write(" ")
        # Set title aligned to the left
        st.markdown("<h1 style='text-align: left;'>Unveiling Vulnerability Dynamics: A Comprehensive Analytical Tool for Ukraine</h1>", unsafe_allow_html=True)

        # Add descriptive text
        st.write("""
            Gain valuable insights into the vulnerability landscape of Ukraine with the powerful analytical platform.
            Leverage interactive visualizations and robust analysis tools to explore the intricate dynamics of the Washington Group Disability Score,
            the Reduced Coping Strategy Index (rCSI), and the Livelihood Coping Strategy Index (LCSI).
            Uncover how these crucial indicators of vulnerability are distributed across various demographics and geographical regions within Ukraine.
        """)


    with col2:
        # Assuming 'geo_df' is your GeoDataFrame
        gdf = geo_df.set_index("shapeName")
        gdf["area"] = gdf.geometry.area

        # Convert GeoDataFrame to a format that can be used with pydeck
        geojson = gdf.__geo_interface__

        # Define a layer to be used in pydeck
        layer = pdk.Layer(
            "GeoJsonLayer",
            data=geojson,
            get_fill_color="[200, 30, 0, 160]",  # Adjust the color as needed
            pickable=True,
        )

        # Set the initial view
        view_state = pdk.ViewState(latitude=gdf.centroid.y.mean(), longitude=gdf.centroid.x.mean(), zoom=6)

        # Render the map with pydeck
        r = pdk.Deck(layers=[layer], initial_view_state=view_state, map_style="mapbox://styles/mapbox/light-v9")

        # Display the map in the Streamlit app
        st.pydeck_chart(r)

#---------------------------------------------------------------

# EDA page

if menu_id == "EDA":
    st.write(" ")
    st.subheader('Exploratory Data Analysis')

    # Counts of unique values in 'Respondent Gender'
    gender_counts = ukraine_data['Respondent Gender'].value_counts().reset_index()
    gender_counts.columns = ['Gender', 'Count']
    gender_counts['Gender'] = gender_counts['Gender'].map({0: 'Male', 1: 'Female'})

    # Create the pie chart for Respondent Gender
    fig_gender = px.pie(gender_counts, names='Gender', values='Count',
                        title='Distribution of Respondent Gender',
                        labels={'Gender': 'Gender', 'Count': 'Count'})

    # Counts of unique values in 'Respondent Age'
    age_counts = ukraine_data['Respondent Age'].value_counts().reset_index()
    age_counts.columns = ['Age', 'Count']

    # Create the histogram for Age Distribution of Respondents
    fig_age = px.histogram(age_counts, x='Age', y='Count',
                           title='Age Distribution of Respondents',
                           labels={'Age': 'Age', 'Count': 'Frequency'},
                           template='plotly_white')

    # Disable gridlines
    fig_age.update_layout(xaxis_showgrid=False, yaxis_showgrid=False)

    # Display both charts side by side
    col1, col2 = st.columns(2)
    with col1:
        st.plotly_chart(fig_gender)

    with col2:
        st.plotly_chart(fig_age)

    # Creating a histogram plot using Plotly to visualize the 'disability_count' column
    fig_disability_count = px.histogram(ukraine_data, x='disability_count', title='Distribution of Disability Count')
    fig_disability_count.update_layout(xaxis_title='Disability Count', yaxis_title='Number of Respondents')
    # Remove gridlines as per previous preference
    fig_disability_count.update_layout(xaxis_showgrid=False, yaxis_showgrid=False)

    # Filter necessary columns
    data_filtered = ukraine_data[['Respondent Gender', 'currently employed']]

    # Rename the columns for clarity in the plot
    data_filtered = data_filtered.rename(columns={'Respondent Gender': 'Gender', 'currently employed': 'Employed'})
    data_filtered['Gender'] = data_filtered['Gender'].map({0: 'Male', 1: 'Female'})
    data_filtered['Employed'] = data_filtered['Employed'].map({0.0: 'Unemployed', 1.0: 'Employed'})

    # Create the distribution plot
    fig_employment = px.histogram(data_filtered, x='Gender', color='Employed', barmode='group',
                   category_orders={'Gender': ['Male', 'Female'], 'Employed': ['Employed', 'Unemployed']},
                   title='Distribution of Employment Status by Gender')
    # Disable gridlines
    fig_employment.update_layout(xaxis_showgrid=False, yaxis_showgrid=False)

    # Display both charts side by side
    col1, col2 = st.columns(2)
    with col1:
        st.plotly_chart(fig_disability_count)

    with col2:
        st.plotly_chart(fig_employment)

    # Count the frequency of each marital status
    marital_status_counts = ukraine_data['Marital status'].value_counts().reset_index()
    marital_status_counts.columns = ['Marital Status', 'Count']

    # Create the bar chart
    fig_marital = px.bar(marital_status_counts, x='Marital Status', y='Count',
             title='Distribution of Marital Status',
             labels={'Count':'Number of Respondents'},
             color='Marital Status',
             text_auto=True)

    # Disable gridlines
    fig_marital.update_layout(xaxis_showgrid=False, yaxis_showgrid=False)

    # Histogram for the distribution of chronic disease
    fig_chronic = px.histogram(ukraine_data, x='chronic', nbins=50, title='Distribution of Chronic Conditions Among Respondents')
    fig_chronic.update_layout(xaxis_title='Number of Chronic Conditions', yaxis_title='Count of Respondents', xaxis_showgrid=False, yaxis_showgrid=False)


    # Display both charts side by side
    col1, col2 = st.columns(2)
    with col1:
        st.plotly_chart(fig_marital)
    with col2:
        st.plotly_chart(fig_chronic)


    # Map the 'is_elderly' to more descriptive labels
    elderly_data = ukraine_data.copy()
    elderly_data['Elderly Status'] = elderly_data['is_elderly'].map({0: 'Not Elderly', 1: 'Elderly'})

    # Create the Sunburst plot for Elderly
    fig_elderly = px.sunburst(elderly_data, path=['Elderly Status'], title='Distribution of Elderly in the Data')

    # Map the 'is_kid' to more descriptive labels
    kids_data = ukraine_data.copy()
    kids_data['Kids Status'] = kids_data['is_kid'].map({0: 'No Kids', 1: 'Kids'})

    # Create the Sunburst plot for Kids
    fig_kids = px.sunburst(kids_data, path=['Kids Status'], title='Distribution of Kids in the Data')

    # Display both charts side by side
    col1, col2 = st.columns(2)
    with col1:
        st.plotly_chart(fig_elderly)
    with col2:
        st.plotly_chart(fig_kids)


#----------------------------------------------------------------

# Vulnerability Scores page

if menu_id == "Vulnerability Scores":
    st.write(" ")
    st.subheader('Score Distributions')
    gender = st.selectbox("Select Gender", options=["All", "Male", "Female"], index=0)
    if gender == "Male":
        filtered_data = ukraine_data[ukraine_data['Respondent Gender'] == 0]
    elif gender == "Female":
        filtered_data = ukraine_data[ukraine_data['Respondent Gender'] == 1]
    else:
        filtered_data = ukraine_data

    # Classify the LCSI score
    def categorize_lcsi(score):
        if score >= 52:
            return 'Emergency'
        elif score >= 23:
            return 'Crisis'
        elif score >= 8:
            return 'Stress'
        else:
            return 'None'

    filtered_data['lcsi_category'] = filtered_data['lcsi score'].apply(categorize_lcsi)
    lcsi_distribution = filtered_data['lcsi_category'].value_counts().reset_index()
    lcsi_distribution.columns = ['Category', 'Count']

    # Classify the RCSI score
    def categorize_rcsi(score):
        if score <= 3:
            return 'Acceptable'
        elif score <= 18:
            return 'Emergency'
        elif score <= 56:
            return 'Crisis'

    filtered_data['rcsi_category'] = filtered_data['rcsi score'].apply(categorize_rcsi)
    rcsi_distribution = filtered_data['rcsi_category'].value_counts().reset_index()
    rcsi_distribution.columns = ['Category', 'Count']

    # Classify the WG score into quantiles and convert intervals to strings
    filtered_data['wg_quantiles'] = pd.qcut(filtered_data['wg score'], q=4, duplicates='drop').astype(str)
    wg_quantiles_distribution = filtered_data['wg_quantiles'].value_counts().reset_index()
    wg_quantiles_distribution.columns = ['Quantile', 'Count']

    # Define the mapping between quantile intervals and desired labels
    quantile_labels = {
        '(0.0, 1.0]': '(0, 1]',
        '(1.0, 2.0]': '(1, 2]',
        '(2.0, 12.0]': '(2, 12]'
    }

    # Create a new column with the desired labels
    wg_quantiles_distribution['Quantile_Label'] = wg_quantiles_distribution['Quantile'].map(quantile_labels)


    # Plotting LCSI distribution
    fig_lcsi = px.pie(lcsi_distribution, names='Category', values='Count', hole=0.5, title='LCSI Score Distribution')
    fig_lcsi.update_layout(legend_title_text='LCSI Categories')
    st.plotly_chart(fig_lcsi)

    # Plotting RCSI distribution
    fig_rcsi = px.pie(rcsi_distribution, names='Category', values='Count', hole=0.5, title='RCSI Score Distribution')
    fig_rcsi.update_layout(legend_title_text='RCSI Categories')
    st.plotly_chart(fig_rcsi)

    # Plotting WG Score Distribution
    fig_wg = px.pie(wg_quantiles_distribution, names='Quantile_Label', values='Count', hole=0.5, title='WG Score Distribution')
    fig_wg.update_layout(legend_title_text='WG Categories')
    st.plotly_chart(fig_wg)

#--------------------------------------------------------------

# Vulnerability Map

if menu_id == "Vulnerability Map":
    st.write(" ")
    st.subheader('Distribution of vulnerability scores')

    # Aggregate the mean scores by oblast
    scores_agg = ukraine_data.groupby('shapeName').agg({
    'latitude': 'mean',  # Assuming one set of coordinates per oblast for simplicity
    'longitude': 'mean',
    'wg score': 'mean',
    'rcsi score': 'mean',
    'lcsi score': 'mean'
    }).reset_index()


    # Assuming geo_df is your GeoDataFrame with the 'geometry' and mean scores for each oblast
    # Merge scores_agg with geo_df to include mean scores in geo_df
    geo_df = geo_df.merge(scores_agg, on='shapeName')

    # Convert geo_df to GeoJSON
    geo_json = geo_df.to_json()

    # Streamlit selector for the score type (same as before)
    score_type = st.selectbox('Choose a score type:', ['wg score', 'rcsi score', 'lcsi score'])

    # Initialize a Folium map (same as before)
    m = folium.Map(location=[48.3794, 31.1656], zoom_start=6)

    # Function to determine the color based on the score
    def get_color(score):
        if score <= 1:
            return 'green'
        elif score <= 2:
            return 'yellow'
        elif score <= 4:
            return 'orange'
        else:
            return 'red'

    # Define the style function
    def style_function(feature):
        score = feature['properties'][score_type]  # Get the score type from the feature's properties
        return {
            'fillColor': get_color(score),
            'color': 'black',  # Border color of the oblast
            'weight': 1,  # Border width
            'fillOpacity': 0.7,
        }

    # Add the GeoJSON to the map with styling
    folium.GeoJson(
        geo_json,
        style_function=style_function,
        tooltip=folium.features.GeoJsonTooltip(
            fields=['shapeName', score_type],
            aliases=['Oblast', 'Score'],
            localize=True
        )
    ).add_to(m)

    # Display the map in Streamlit
    st_data = st_folium(m, width=1500)

#-------------------------------------------------------------------------------

if menu_id == "Score Calculation":
    st.write(" ")
    st.subheader('Washington Group Score')

    # Define the questionnaire
    questions = {
        "Seeing": ["No, no difficulty", "Yes, some difficulty", "Yes, a lot of difficulty", "Cannot do it at all"],
        "Hearing": ["No, no difficulty", "Yes, some difficulty", "Yes, a lot of difficulty", "Cannot do it at all"],
        "Walking or Climbing Steps": ["No, no difficulty", "Yes, some difficulty", "Yes, a lot of difficulty", "Cannot do it at all"],
        "Remembering or Concentrating": ["No, no difficulty", "Yes, some difficulty", "Yes, a lot of difficulty", "Cannot do it at all"],
        "Self-Care": ["No, no difficulty", "Yes, some difficulty", "Yes, a lot of difficulty", "Cannot do it at all"],
        "Communicating": ["No, no difficulty", "Yes, some difficulty", "Yes, a lot of difficulty", "Cannot do it at all"]
    }

    # Create columns for the questionnaire
    col1, col2 = st.columns(2)

    # Assign questions to each column
    questions_col1 = ["Seeing", "Hearing", "Walking or Climbing Steps"]
    questions_col2 = ["Remembering or Concentrating", "Self-Care", "Communicating"]

    # Create a dictionary to store responses
    responses = {}

    # Display the questions in the first column
    with col1:
        for question in questions_col1:
            responses[question] = st.selectbox(question, questions[question])

    # Display the questions in the second column
    with col2:
        for question in questions_col2:
            responses[question] = st.selectbox(question, questions[question])

    # Assign numerical values to the responses
    value_mapping = {
        "No, no difficulty": 0,
        "Yes, some difficulty": 1,
        "Yes, a lot of difficulty": 2,
        "Cannot do it at all": 3
    }

    # Calculate the score
    score = sum(value_mapping[response] for response in responses.values())

    # Display the score with custom formatting
    if st.button('Calculate WG Score'):
        # Calculate the WG score
        # You should replace `score` with the actual calculated score.
        wg_score = score 

        # Define the light grey background color
        background_color = "#F0F0F0"  # Light grey

        # Create the result HTML with light grey background, centered, and bold
        result_html = f"""
        <div style='background-color: {background_color}; border-radius: 5px; padding: 10px; text-align: center;'>
            <h1 style='color: #000000; font-size: 20px;'> WG score </h1>
            <h1 style='color: #000000; font-size: 30px;'> <span style='font-weight: bold;'>{wg_score}</span> </h1>
        </div>
        """

        # Display the result
        st.markdown(result_html, unsafe_allow_html=True)


    st.write(" ")
    st.subheader('Reduced Coping Strategy Index Score')

    # Define the questions and severity weights
    questions = {
        "rcsi cheaper food": "During the last 7 days, were there days when your household had to rely on less preferred and less expensive food?",
        "rcsi borrow food": "During the last 7 days, were there days when your household had to borrow food or rely on help from a relative or friend?",
        "rcsi limit portion": "During the last 7 days, were there days when your household had to limit portion sizes at meal times?",
        "rcsi restrict consumption adults": "During the last 7 days, were there days when your household had to restrict consumption by adults for small children to eat?",
        "rcsi reduce meals number": "During the last 7 days, were there days when your household had to reduce the number of meals eaten in a day?"
    }

    severity_weights = {
        "rcsi cheaper food": 1,
        "rcsi borrow food": 2,
        "rcsi limit portion": 1,
        "rcsi restrict consumption adults": 3,
        "rcsi reduce meals number": 1
    }

    # Initialize dictionary to hold responses
    responses = {}

    # UI to gather responses
    for key, question in questions.items():
        responses[key] = st.selectbox(question, options=list(range(8)), index=0)


    # Button to calculate the score
    if st.button("Calculate RCSI Score"):
        # Calculate the RCSI score based on severity weights and responses
        rcsi_score = sum(responses[key] * severity_weights[key] for key in questions)
        
        # Define the light grey background color
        background_color = "#F0F0F0"  # Light grey

        # Create the result HTML with light grey background, centered, and bold
        result_html = f"""
        <div style='background-color: {background_color}; border-radius: 5px; padding: 10px; text-align: center;'>
            <h1 style='color: #000000; font-size: 20px;'> RCSI score </h1>
            <h1 style='color: #000000; font-size: 30px;'> <span style='font-weight: bold;'>{rcsi_score}</span> </h1>
        </div>
        """

        # Display the result
        st.markdown(result_html, unsafe_allow_html=True)




#-------------------------------------------------------------------------------

if menu_id == "Vulnerability Level":
    # Selecting the independent variables and the dependent variable
    X = ukraine_data[['currently employed', 'wg score', 'Displaced', 'chronic', 'is_elderly', 'is_kid', 'rcsi score', 'disability_count']]
    y = ukraine_data['lcsi score']

    # Splitting the dataset into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Initializing the Linear Regression model
    model = LinearRegression()

    # Fitting the model on the training data
    model.fit(X_train, y_train)

    # Predicting on the test set
    y_pred = model.predict(X_test)

    # Calculating the performance metrics
    mse = mean_squared_error(y_test, y_pred)
    rmse = mse ** 0.5
    r2 = r2_score(y_test, y_pred)

    # Assuming 'model' is your trained LinearRegression model
    dump(model, 'linear_regression_model.joblib')

    # Load the trained model
    model = load('linear_regression_model.joblib')

    # Streamlit app title
    st.title('Livelihood Coping Strategy Index')

    # # Additional fields for gathering information or providing instructions
    # st.markdown('### Personal Information')
    # # These fields are not related to the model and are for demonstration
    # name = st.text_input('Name')
    # MobileNumber = st.text_input('Mobile Number')
    st.markdown('### Mandatory information')

    col1, col2 = st.columns(2)

    with col1:
        # User inputs for the left column
        currently_employed = st.number_input('Currently Employed (0 = No, 1 = Yes)', min_value=0, max_value=1, value=0)
        wg_score = st.number_input('WG Score', min_value=0.0, max_value=12.0, value=0.0)
        displaced = st.number_input('Displaced (0 = No, 1 = Yes)', min_value=0, max_value=1, value=0)
        chronic = st.number_input('Members with chronic disease (Count)', min_value=0, max_value=15, value=0)

    with col2:
        # User inputs for the right column
        is_elderly = st.number_input('Presence of old members (0 = No, 1 = Yes)', min_value=0, max_value=1, value=0, key='is_elderly')
        is_kid = st.number_input('Presence of kids (0 = No, 1 = Yes)', min_value=0, max_value=1, value=0, key='is_kid')
        rcsi_score = st.number_input('RCSI Score', min_value=0.0, max_value=56.0, value=0.0, key='rcsi_score')
        disability_count = st.number_input('Members with disability (Count)', min_value=0, max_value=10, value=0, key='disability_count')

    # Button to make prediction
    if st.button('Vulnerability Level'):
        # Arrange inputs
        input_data = np.array([[currently_employed, wg_score, displaced, chronic, is_elderly, is_kid, rcsi_score, disability_count]])
        # Predict
        prediction = model.predict(input_data)
        predicted_score = prediction[0]

        # Determine the Vulnerability Level based on the predicted score
        if predicted_score < 8:
            vulnerability_level = "Low"
            color = "#FFFBC8"  # Yellow
        elif predicted_score < 23:
            vulnerability_level = "Stress"
            color = "#90EE90"  # Green
        elif predicted_score < 52:
            vulnerability_level = "Crisis"
            color = "#F5A33E"  # Orange
        else:
            vulnerability_level = "Emergency"
            color = "#FF474C"  # Red

        # Define the text color as black
        text_color = "#000000"  # Black

        # Create the colored vulnerability level HTML span with black text color
        colored_vulnerability_level = f"<div style='text-align:center;'><span style='color:{text_color}; font-size:20px;'>{vulnerability_level}</span></div>"

        # Create the colored number HTML span with black text color, bigger font, and bold
        colored_number = f"<div style='text-align:center;'><span style='color:{text_color}; font-size:30px; font-weight:bold;'>{predicted_score:.2f}</span></div>"

        # Display the colored Vulnerability Level and colored number inside a box
        st.markdown(f'<div style="background-color: {color}; border-radius: 5px; padding: 24px; text-align:center;">{colored_vulnerability_level}{colored_number}</div>', unsafe_allow_html=True)

